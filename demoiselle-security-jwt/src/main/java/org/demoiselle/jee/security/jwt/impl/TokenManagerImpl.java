package org.demoiselle.jee.security.jwt.impl;

import java.security.KeyFactory;
import java.security.KeyPair;
import java.security.KeyPairGenerator;
import java.security.NoSuchAlgorithmException;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.security.spec.InvalidKeySpecException;
import java.security.spec.PKCS8EncodedKeySpec;
import static java.util.Base64.getDecoder;
import static java.util.Base64.getEncoder;
import java.util.List;
import java.util.Map;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.annotation.PostConstruct;
import javax.annotation.Priority;
import javax.enterprise.context.ApplicationScoped;
import javax.inject.Inject;
import javax.servlet.http.HttpServletRequest;
import static javax.ws.rs.Priorities.AUTHENTICATION;
import org.demoiselle.jee.core.api.security.DemoisellePrincipal;
import org.demoiselle.jee.core.api.security.Token;
import org.demoiselle.jee.core.api.security.TokenManager;
import org.demoiselle.jee.security.exception.DemoiselleSecurityException;
import static org.jose4j.jws.AlgorithmIdentifiers.RSA_USING_SHA256;
import org.jose4j.jws.JsonWebSignature;
import org.jose4j.jwt.JwtClaims;
import org.jose4j.jwt.consumer.InvalidJwtException;
import org.jose4j.jwt.consumer.JwtConsumer;
import org.jose4j.jwt.consumer.JwtConsumerBuilder;
import org.jose4j.keys.RsaKeyUtil;
import org.jose4j.lang.JoseException;
import static java.security.KeyPairGenerator.getInstance;

/**
 * The security risk component JWT use a strategy where a pair of asymmetric
 * keys is necessary. The keys can be generated by you on linux
 * https://help.ubuntu.com/community/SSH/OpenSSH/Keys or leave the parameters
 * blank and see the log suggested keys The JWT standard is one of the safest
 * and performers today, to learn more check https://jwt.io/
 *
 */
@ApplicationScoped
@Priority(AUTHENTICATION)
public class TokenManagerImpl implements TokenManager {

    private PublicKey publicKey;
    private PrivateKey privateKey;

    @Inject
    private Logger logger;

    @Inject
    private Token token;

    @Inject
    private DemoiselleSecurityJWTConfig config;

    @Inject
    private DemoisellePrincipal loggedUser;

    /**
     * Starts keys that are on file demoiselle-security-jwt.properties that
     * should be in the resource of your project
     */
    @PostConstruct
    public void init() {
        if (publicKey == null) {
            logger.info("Demoiselle Module: JWT");
            logger.log(Level.INFO, "Type server: {0}", config.getType() != null ? config.getType() : "Error");
            logger.log(Level.INFO, "Primary key: {0}", config.getPrivateKey() != null ? !config.getPrivateKey().isEmpty() : "Error");
            logger.log(Level.INFO, "Public key: {0}", config.getPublicKey() != null ? !config.getPublicKey().isEmpty() : "Error");
            logger.log(Level.INFO, "Age token in minutes: {0}", config.getTempo() != null ? config.getTempo() : "Error");
            logger.log(Level.INFO, "Issuer: {0}", config.getRemetente() != null ? config.getRemetente() : "Error");
            logger.log(Level.INFO, "Audience: {0}", config.getDestinatario() != null ? config.getDestinatario() : "Error");
            try {

                if (config.getType() == null) {
                    throw new DemoiselleSecurityException("Escolha o tipo de autenticação, ver documentação", 500);
                }

                if (!config.getType().equalsIgnoreCase("slave") && !config.getType().equalsIgnoreCase("master")) {
                    throw new DemoiselleSecurityException("Os tipos de servidor são master ou slave, ver documentação", 500);
                }

                if (config.getType().equalsIgnoreCase("slave")) {
                    if (config.getPublicKey() == null || config.getPublicKey().isEmpty()) {
                        logger.warning("Coloque a chave pública no arquivo demoiselle-security-jwt.properties, ver documentação");
                        throw new DemoiselleSecurityException("Informe a chave pública no arquivo de configuração do projeto, ver documentação", 500);
                    } else {
                        publicKey = getPublic();
                    }
                }

                if (config.getType().equalsIgnoreCase("master")) {
                    privateKey = getPrivate();
                    publicKey = getPublic();
                }

            } catch (DemoiselleSecurityException ex) {
                logger.severe(ex.getMessage());
            } catch (JoseException | InvalidKeySpecException | NoSuchAlgorithmException ex) {
                logger.severe(ex.getMessage());
            }

        }
    }

    /**
     * Pega o token que está no escopo de request e extrai o usuário de dentro
     * do token validando o usuário nesse momento
     * <p>
     * Pick up the token that is in the request scope and draws the user into
     * the token validating the user at this time
     *
     * @return
     */
    @Override
    public DemoisellePrincipal getUser() {
        if (token.getKey() != null && !token.getKey().isEmpty()) {
            try {
                JwtConsumer jwtConsumer = new JwtConsumerBuilder()
                        .setRequireExpirationTime() // the JWT must have an expiration time
                        .setAllowedClockSkewInSeconds(60) // allow some leeway in validating time based claims to account for clock skew
                        .setExpectedIssuer(config.getRemetente()) // whom the JWT needs to have been issued by
                        .setExpectedAudience(config.getDestinatario()) // to whom the JWT is intended for
                        .setVerificationKey(publicKey)
                        .build(); // create the JwtConsumer instance
                JwtClaims jwtClaims = jwtConsumer.processToClaims(token.getKey());
                loggedUser.setIdentity((String) jwtClaims.getClaimValue("identity"));
                loggedUser.setName((String) jwtClaims.getClaimValue("name"));
                loggedUser.setRoles((List) jwtClaims.getClaimValue("roles"));
                loggedUser.setPermissions((Map) jwtClaims.getClaimValue("permissions"));
                loggedUser.setParams((Map) jwtClaims.getClaimValue("params"));

                return loggedUser;
            } catch (InvalidJwtException ex) {
                loggedUser = null;
                token.setKey(null);
                logger.severe(ex.getMessage());
            }
        }
        return null;
    }

    /**
     * @param user
     */
    @Override
    public void setUser(DemoisellePrincipal user) {
        try {
            JwtClaims claims = new JwtClaims();
            claims.setIssuer(config.getRemetente());
            claims.setAudience(config.getDestinatario());
            claims.setExpirationTimeMinutesInTheFuture(config.getTempo());
            claims.setGeneratedJwtId();
            claims.setIssuedAtToNow();
            claims.setNotBeforeMinutesInThePast(1);

            claims.setClaim("identity", (user.getIdentity()));
            claims.setClaim("name", (user.getName()));
            claims.setClaim("roles", (user.getRoles()));
            claims.setClaim("permissions", (user.getPermissions()));
            claims.setClaim("params", (user.getParams()));

            JsonWebSignature jws = new JsonWebSignature();
            jws.setPayload(claims.toJson());
            jws.setKey(privateKey);
            jws.setKeyIdHeaderValue("demoiselle-security-jwt");
            jws.setAlgorithmHeaderValue(RSA_USING_SHA256);
            token.setKey(jws.getCompactSerialization());
            token.setType("JWT");
        } catch (JoseException ex) {
            logger.severe(ex.getMessage());
        }

    }

    /**
     *
     * @return
     */
    @Override
    public boolean validate() {
        return getUser() != null;
    }

    private PrivateKey getPrivate() throws NoSuchAlgorithmException, InvalidKeySpecException {

        if (config.getPrivateKey() == null) {
            KeyPairGenerator keyGenerator = getInstance("RSA");
            keyGenerator.initialize(2_048);
            KeyPair kp = keyGenerator.genKeyPair();
            publicKey = kp.getPublic();
            privateKey = kp.getPrivate();
            config.setPrivateKey("-----BEGIN PRIVATE KEY-----" + getEncoder().encodeToString(privateKey.getEncoded()) + "-----END PRIVATE KEY-----");
            config.setPublicKey("-----BEGIN PUBLIC KEY-----" + getEncoder().encodeToString(publicKey.getEncoded()) + "-----END PUBLIC KEY-----");
            logger.log(Level.WARNING, "privateKey={0}", config.getPrivateKey());
            logger.log(Level.WARNING, "publicKey={0}", config.getPublicKey());
        }
        byte[] keyBytes = getDecoder().decode(config.getPrivateKey().replace("-----BEGIN PRIVATE KEY-----", "").replace("-----END PRIVATE KEY-----", ""));
        PKCS8EncodedKeySpec spec = new PKCS8EncodedKeySpec(keyBytes);
        KeyFactory kf = KeyFactory.getInstance("RSA");
        return kf.generatePrivate(spec);
    }

    private PublicKey getPublic() throws JoseException, InvalidKeySpecException {
        RsaKeyUtil rsaKeyUtil = new RsaKeyUtil();
        return rsaKeyUtil.fromPemEncoded(config.getPublicKey());
    }

}
